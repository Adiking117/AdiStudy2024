practice.sql
CREATE DATABASE payroll;
go

USE payroll;

CREATE TABLE emp(
	empno INTEGER NOT NULL,
	ename VARCHAR(10),
	job VARCHAR(9),
	mgr INTEGER,
	hiredate DATE,
	sal REAL,
	comm REAL,
	deptno INTEGER
);

BEGIN TRANSACTION
INSERT INTO EMP VALUES
        (7369, 'SMITH',  'CLERK',     7902,
        '1980-12-17',  800, NULL, 20);
INSERT INTO EMP VALUES
        (7499, 'ALLEN',  'SALESMAN',  7698,
        '1981-02-20', 1600,  300, 30);
INSERT INTO EMP VALUES
        (7521, 'WARD',   'SALESMAN',  7698,
        '1981-02-22', 1250,  500, 30);
INSERT INTO EMP VALUES
        (7566, 'JONES',  'MANAGER',   7839,
        '1981-04-02',  2975, NULL, 20);
INSERT INTO EMP VALUES
        (7654, 'MARTIN', 'SALESMAN',  7698,
        '1981-10-28', 1250, 1400, 30);
INSERT INTO EMP VALUES
        (7698, 'BLAKE',  'MANAGER',   7839,
        '1981-05-01',  2850, NULL, 30);
INSERT INTO EMP VALUES
        (7782, 'CLARK',  'MANAGER',   7839,
        '1981-06-09',  2450, NULL, 10);
INSERT INTO EMP VALUES
        (7788, 'SCOTT',  'ANALYST',   7566,
        '1982-12-09', 3000, NULL, 20);
INSERT INTO EMP VALUES
        (7839, 'KING',   'PRESIDENT', NULL,
        '1981-11-17', 5000, NULL, 10);
INSERT INTO EMP VALUES
        (7844, 'TURNER', 'SALESMAN',  7698,
        '1981-10-08',  1500,    0, 30);
INSERT INTO EMP VALUES
        (7876, 'ADAMS',  'CLERK',     7788,
        '1983-01-12', 1100, NULL, 20);
INSERT INTO EMP VALUES
        (7900, 'JAMES',  'CLERK',     7698,
        '1981-02-20',   950, NULL, 30);
INSERT INTO EMP VALUES
        (7902, 'FORD',   'ANALYST',   7566,
        '1981-12-03',  3000, NULL, 20);
INSERT INTO EMP VALUES
        (7934, 'MILLER', 'CLERK',     7782,
        '1982-01-23', 1300, NULL, 10);

commit;s

CREATE TABLE DEPT
       (DEPTNO INTEGER,
        DNAME VARCHAR(14),
        LOC VARCHAR(13) 
);

BEGIN TRANSACTION
INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT VALUES (20, 'RESEARCH',   'DALLAS');
INSERT INTO DEPT VALUES (30, 'SALES',      'CHICAGO');
INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON');	
COMMIT;

SELECT empno,ename,sal FROM emp;
SELECT * FROM EMP;
SELECT * FROM DEPT;

-- 1. Insert a record in table
INSERT INTO EMP VALUES (1117,'ADITYA','CLERK',1007,'2003-01-17',5500,30,20);
-- doesnt work
INSERT INTO EMP VALUES (1118,'PRANAV');

-- 2. Inserting values of specific columns
INSERT INTO EMP (empno,ename) VALUES (1110,'PARTTH');

-- 3. Accessing Data as per condition
SELECT * FROM EMP WHERE DEPTNO=10;		-- searching happens in HDD , we can call pseudo columns

SELECT * FROM EMP WHERE SAL>2000;

SELECT * FROM EMP WHERE SAL<3000;

SELECT * FROM EMP WHERE SAL>2000 AND SAL<3000;
SELECT * FROM EMP WHERE SAL BETWEEN 2000 AND 3000;		-- BETWEEN is much faster than relations

SELECT * FROM EMP WHERE (DEPTNO=10 OR SAL>2000) AND SAL<3000;
SELECT * FROM EMP WHERE SAL < 3000 AND (SAL>2000 OR DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE DEPTNO=10));

SELECT * FROM EMP WHERE JOB = 'MANAGER' OR JOB = 'CLERK';
SELECT ENAME , SAL , SAL*12 "ANNUALSALARY" FROM EMP;		-- ANNUALSALARY IS A PSEUDO COLUMN stored in RAM

SELECT ENAME,SAL, SAL*12*0.4 "HRA", SAL*12*0.2 "GRA" , SAL*12 "ANNUALSALARY" FROM EMP;

SELECT JOB FROM EMP;
SELECT DISTINCT JOB FROM EMP;		--Distinct in the query sorting in the RAM
SELECT DISTINCT JOB,ENAME FROM EMP;		-- Distinct columns must not be used with regular columns

SELECT ENAME, SYS.fn_PhysLocFormatter(%%physloc%%) FROM emp;

SELECT * FROM EMP ORDER BY EMPNO ASC;		-- Orders by address

-- There is no upper limit on number of columns in ORDER BY clause
-- SELECT ... ORDER BY country city 
-- WHERE clause is specified before order by clause

SELECT DEPTNO,JOB,ENAME,SAL FROM EMP ORDER BY ENAME;
SELECT DEPTNO,JOB,ENAME,SAL FROM EMP ORDER BY 3;		-- 3rd Column

SELECT * FROM EMP WHERE ENAME > 'A' AND ENAME < 'B';
SELECT * FROM EMP WHERE ENAME LIKE 'A%';
SELECT * FROM EMP WHERE ENAME LIKE 'A%' OR ENAME LIKE '%A' OR ENAME LIKE '%A%';
SELECT * FROM EMP WHERE ENAME LIKE '__A%';
SELECT * FROM EMP WHERE ENAME LIKE '____';

SELECT * FROM EMP WHERE HIREDATE BETWEEN '1982-01-19' AND '1983-01-01';


SELECT * FROM EMP;

-- Asssignment 1
-- 1
BEGIN TRANSACTION
UPDATE EMP SET SAL=1000 WHERE EMPNO=7369;
COMMIT

--2 P
UPDATE EMP SET SAL=1000, COMM=200 WHERE EMPNO=7499;

--3
 DELETE FROM EMP WHERE EMPNO IN (SELECT DISTINCT EMPNO FROM EMP WHERE EMPNO=1117) 
 SELECT DISTINCT EMPNO FROM EMP 
--4 
SELECT ENAME+' '+ENAME FROM EMP WHERE ENAME='SMITH';
SELECT CONCAT(ENAME,' ',ENAME) FROM EMP WHERE ENAME='SMITH'

--5 
SELECT 'MR '+ENAME FROM EMP 
SELECT CONCAT('MR ',ENAME) FROM EMP;

--6 
SELECT UPPER(ENAME) FROM EMP

--7 
SELECT LOWER(ENAME) FROM EMP;

--8 
SELECT LEN(ENAME) FROM EMP;

--9
SELECT CONCAT('******', ENAME IN (SELECT ENAME FROM EMP WHERE ENAME='ADAMS') ,'*******') FROM EMP;

SELECT CONCAT('******',ENAME,'******') FROM EMP WHERE ENAME='ADAMS';

SELECT CONCAT(replicate('*',7),(SELECT ENAME FROM EMP WHERE ENAME='ADAMS'),replicate('*',7)) FROM EMP

SELECT replicate('*',7) + (SELECT ENAME FROM EMP WHERE ENAME='ADAMS') +replicate('*',7) FROM EMP;

SELECT CONCAT(REPLICATE('*', 20- (SELECT LEN((SELECT ENAME FROM EMP WHERE ENAME='ADAMS'))/2 ) ,ENAME,REPLICATE('*',(20-(SELECT LEN((SELECT ENAME FROM EMP WHERE ENAME='ADAMS')) FROM EMP)/2)) FROM EMP)/2)),

(SELECT LEN((SELECT ENAME FROM EMP WHERE ENAME='ADAMS'))/2 )







-- DAY2

BEGIN TRANSACTION

INSERT INTO EMP (EMPNO,ENAME) VALUES (1117,'ADITYA');
SAVE TRANSACTION T1
-- first insert is done and then the transaction is done

INSERT INTO EMP (EMPNO,ENAME) VALUES (1118,'PRANAV');
SAVE TRANSACTION T2

INSERT INTO EMP (EMPNO,ENAME) VALUES (1119,'PARTH');
SAVE TRANSACTION T3

ROLLBACK TRANSACTION T2

-- COMMIT

-- Multiple DML operations (INSERT,UPDTAE,DELETE) a single transaction

-- Create a singlw transaction (unit of work)
-- these large trasACTION CAN HAVE SUBUNUTS WHICH CAN BE SAVED USING SAVEPOINTS
-- MULTIPLE SAVEPOINTS CAN HAVE SAME NAME
-- DIDSAADVANTAGE: LAST ONE OVERRIRDES THE PREVIOUS ONE
-- ADVANTAGE: IN THESE SUBUNITS OF WORK YOU CAN ROOLLBACK TO A PARATCIALR TRNASATUON




SELECT * FROM EMP;

UPDATE EMP SET ENAME = LOWER('JACK') WHERE ENAME='ADITYA'

SELECT LTRIM(ENAME) FROM EMP;

SELECT SUBSTRING(ENAME,1,2) FROM EMP

SELECT ENAME FROM EMP 
SELECT * FROM EMP WHERE SOUNDEX(ENAME)= SOUNDEX('KEENG')

SELECT ROUND(999.99223455,2);
SELECT CEILING(983.34);

SELECT YEAR(GETDATE())

SELECT EMPNO , ENAME , YEAR(GETDATE())-YEAR(HIREDATE) FROM EMP  
SELECT EMPNO, ENAME , DATEDIFF(YYYY , HIREDATE , GETDATE()) FROM EMP;

SELECT * FROM EMP WHERE COMM IS NULL;

UPDATE EMP SET COMM = 0 WHERE COMM IS NULL

SELECT ISNULL(COMM, 0) FROM EMP 
SELECT EMPNO , SAL , SAL+COMM FROM EMP
-- ANY EXPRESSION OPERATES WITH NULL RESULT  IS NULL


SELECT EMPNO,DEPTNO,
CASE
	WHEN DEPTNO = 10 then 'TRAINING'
	WHEN DEPTNO = 20 then 'EXPORTS'
	when DEPTNO = 30 then 'MARKETING'
	when DEPTNO = 40 then 'PRODUCTION'
	WHEN DEPTNO IS NULL THEN 'OTHERS'
	ELSE 'PRODUCTION'
END as [DEPTNO] 
FROM EMP;


SELECT COUNT(*) 'COUNT' , MIN(SAL) 'MINIMUM' ,MAX(SAL) 'MAXIMUM' ,AVG(SAL) 'AVERAGE' FROM EMP;

-- TO GENERATE THE CURRENT NUMBER OF EG.PRODUCTS,ORDERS,... , THE IDS OF LATEST ENTRY WILL BE GENERATED WITH THE HELP OF 
-- COUNTER TABLE WHICH WILL STORE THE VALUES OF ENTITY.

-- COUNTER		CURVAL
-- PRODUCT		100
-- ORDERS		1000
-- CUSTOMERS	3000

-- SELECT ENAME , MAX(SAL) FROM EMP;	-- no single row column with aggregate functions
-- SELECT ENAME, MAX(SAL) FROM EMP;		
-- SELECT * FROM EMP WHERE SUM(SAL) > 5000		-- no multiple row fucntion wiuth aggregate fucntions

SELECT DEPTNO , SUM(SAL) FROM EMP GROUP BY DEPTNO

-- group by works in following steps
-- bring all the rows from server's harddisk to server's ram  -> Single array
-- sort the array (sorting takes place in ram)
-- creates seperate arrays from department (sum each array)
-- finally only those rows which are grouped will be send to the clients

SELECT JOB, DEPTNO , SUM(SAL) FROM EMP GROUP BY JOB , DEPTNO
-- sequence of the coulms must be maintained and the first one will have lesser number of rows

SELECT DEPTNO FROM EMP GROUP BY DEPTNO HAVING SUM(SAL) > 5000 ORDER BY DEPTNO
-- SELECT -> FROM ->  WHERE -> GROUPBY -> HAVING -> ORDERBY


-- ASSSIGNMENT 2

-- 1) Write a query to extract the year and month from the `hiredate` of each employee.
SELECT EMPNO ,YEAR(HIREDATE), MONTH(HIREDATE) FROM EMP

--2) Write a query to find the total number of employees hired each year.
SELECT COUNT(*) FROM EMP GROUP BY YEAR(HIREDATE) 

--3) Write a query to find the total salary paid to employees hired in each department each year.
SELECT SUM(SAL) FROM EMP GROUP BY DEPTNO,YEAR(HIREDATE) 

--4) Write a query to find departments that have hired more than 5 employees in any given year.
SELECT DEPTNO FROM EMP GROUP BY DEPTNO,YEAR(HIREDATE) HAVING COUNT(*)>5

--5) Write a query to find the average salary of employees in each job role for each department and filter the results to show only those job roles where the average salary is greater than 3000.
SELECT AVG(SAL) FROM EMP GROUP BY DEPTNO,JOB HAVING AVG(SAL)>3000

--6) Write a query to calculate the tenure (in years) of each employee based on their `hiredate`.
SELECT EMPNO, ENAME , DATEDIFF(YYYY , HIREDATE , GETDATE()) FROM EMP;

--7) Write a query to find the total commission paid to employees in each job role hired in each month, but only include results where the total commission is greater than 500.
SELECT SUM(COMM) FROM EMP GROUP BY JOB,MONTH(HIREDATE) HAVING SUM(COMM)>500

--8) Write a query to find the highest salary of employees in each department and display the department number along with the highest salary. Use a nested query to achieve this.
SELECT MAX(SAL),DEPTNO FROM EMP GROUP BY DEPTNO

-- 9) Write a query to list the employees whose salary is greater than the average salary of their respective department.
SELECT * FROM EMP E WHERE SAL> (SELECT AVG(SAL) FROM EMP WHERE DEPTNO=E.DEPTNO GROUP BY DEPTNO)



-- DAY 3

SELECT * FROM DEPT
SELECT * FROM EMP

-- Subqueries


-- SCALAR SUBQUERY // ONE ROW ONE COLUMN
--	MAIN QUERY							INNER/CHILD QUERY
SELECT ENAME FROM EMP WHERE SAL = (SELECT MIN(SAL) FROM EMP);
SELECT ENAME FROM EMP WHERE SAL IN (SELECT MIN(SAL) FROM EMP);

-- SINGLE ROW QUERY -- ONE ROW MULTIPLE COLUMNS
SELECT ENAME FROM EMP WHERE ENAME!='SMITH' AND DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME='SMITH')

DELETE FROM EMP WHERE JOB = (SELECT JOB FROM EMP WHERE ENAME = 'SMITH');

UPDATE EMP SET SAL = 10000 WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME='SMITH')

-- ANY IS WRITTEN FRONT OF QUERY WHICH RETURNS MULTIPLE ROW COLUMNS 
SELECT * FROM EMP WHERE SAL = ANY (SELECT SAL FROM EMP WHERE JOB='MANAGER')

SELECT * FROM EMP WHERE SAL > ANY (SELECT SAL FROM EMP WHERE DEPTNO=20)

-- UPDATE EMP SET SAL = 10000 WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME='SMITH')

-- SELECT MIN(SAL) FROM EMP WHERE SAL >= (SELECT MIN(SAL) FROM EMP WHERE JOB='MANAGER')


SELECT * FROM EMP WHERE SAL > (SELECT MAX(SAL) FROM EMP WHERE JOB='MANAGER')

-- IN CHECKS VALUES WITH SET OF VALUES // USED WHEN SPECIFIFC VALUES ARE RETURNED
SELECT DNAME FROM DEPT WHERE DEPTNO IN (SELECT DISTINCT DEPTNO FROM DEPT)



-- SUB QUERY VS JOINS 

-- FOR ANY JOINING OPERATION , ONLY ONE PLAN IS CREATED IN OPTIMIZER 
SELECT DISTINCT DNAME FROM EMP,DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO -- DISTINCT DOES SORTING AND THEN JOINING (FULL TABLE SCAN)

SELECT DNAME FROM DEPT WHERE EXISTS (SELECT DEPTNO FROM EMP WHERE DEPT.DEPTNO = EMP.DEPTNO) -- SCAN TILL FIRST OCCURENCE
--FOR EVERY SUBQUERY DIFFERENT PLANS ARE CREATED , THUS REDUCING THE SPEED , AND FOR NESTED SUBQUERY THIS TAKES MORE TIMR


-- ASSIGNEMNT 3

-- 1) Write a query to list departments that have more than 3 employees.
SELECT DNAME FROM DEPT WHERE DEPTNO IN (SELECT DEPTNO FROM EMP GROUP BY DEPTNO HAVING COUNT(*) > 3 )


--2) Write a query to calculate the total salary of employees grouped by the location of their department.
SELECT SUM(SAL) FROM DEPT INNER JOIN EMP ON EMP.DEPTNO = DEPT.DEPTNO GROUP BY DEPT.LOC

--3) Write a query to find the employee(s) with the highest salary
SELECT * FROM EMP WHERE SAL = (SELECT MAX(SAL) FROM EMP)

--4) Write a query to find employees who earn the minimum salary in their respective departments.
SELECT * FROM EMP WHERE SAL IN (SELECT MIN(SAL) FROM EMP GROUP BY DEPTNO)


--5) Write a query to list departments that do not have any employees.
SELECT DEPT.DEPTNO , DEPT.DNAME , EMP.ENAME  FROM DEPT LEFT OUTER JOIN EMP ON DEPT.DEPTNO=EMP.DEPTNO WHERE EMP.ENAME IS NULL

--6) Write a query to list employees who joined the company before their manager.
SELECT * FROM EMP E WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE EMPNO=E.MGR)

--7) Write a query to list employees who work in departments located in 'CHICAGO' or 'DALLAS'.
SELECT ENAME,EMPNO, DEPT.DEPTNO, DEPT.LOC FROM DEPT INNER JOIN EMP ON DEPT.DEPTNO = EMP.DEPTNO WHERE LOC IN ('DALLAS','CHICAGO')

--8) Write a query to list employees who are either managers or have the job title 'SALESMAN'.
SELECT * FROM EMP WHERE JOB IN ('MANAGER','SALESMAN')

--9) Write a query to list employees who do not work in departments located in 'NEW YORK' or 'BOSTON'.
SELECT EMP.ENAME , DEPT.LOC FROM DEPT INNER JOIN EMP ON DEPT.DEPTNO = EMP.DEPTNO WHERE DEPT.LOC NOT IN ('NEW YORK','BOSTON')

--10) Write a query to list employees who were hired before any employee in department 30.
SELECT * FROM EMP WHERE HIREDATE < ANY (SELECT HIREDATE FROM EMP WHERE DEPTNO=30)




-- DAY 4

-- VIEWS
-- WITH VIEWS WE DONT DIRECTLY EXPOSE COLUMNS OF TABLE (I.E ABSTRACTED) INSTEAD STORE REFERENCES OF ROWS
-- RESTRICTION OF ACCESS , AS A STORED QUERY (BINARY VERSION OF SELECT QUERY IS STORED AS REFERENCE)
-- NO.OF VIEWS DEPEND ON USER REQUIREMENTS // VIEW NAME ACC TO REQURIEMENTS

CREATE VIEW EMP_VIEW AS SELECT * FROM EMP;

-- SELECT * FROM INFORMATION_SCHEMA.TABLES

CREATE VIEW EMP_VIEW_DEPT_10 AS SELECT * FROM EMP WHERE DEPTNO= 10
SELECT * FROM EMP_VIEW_DEPT_10

-- FOR EXPRESSIONS IN SELECT , CREATE AN ALIAS FOR CREATING VIEW
CREATE OR ALTER VIEW EMP_VIEW_UPENAME_NETSAL AS SELECT UPPER(ENAME) "ENAME" , SAL+ ISNULL(COMM,0) "NET SALARY" FROM EMP 
SELECT * FROM EMP_VIEW_UPENAME_NETSAL

CREATE VIEW EMP_VIEW_ENAME_DNAME AS SELECT EMP.EMPNO , EMP.ENAME , DEPT.DNAME FROM EMP INNER JOIN DEPT ON DEPT.DEPTNO = EMP.DEPTNO
SELECT * FROM EMP_VIEW_ENAME_DNAME


CREATE VIEW EMP_VIEW_ENAME_SAL_COMM AS SELECT ENAME,SAL,COMM FROM EMP;
SELECT * FROM EMP_VIEW_ENAME_SAL_COMM

INSERT INTO EMP_VIEW (EMPNO,ENAME) VALUES (1,'ADITYA')
SELECT * FROM EMP_VIEW

-- ALL THE CONSTRAINTS OF TABLE IS APPLIED ON VIEW MADE FROM THAT TABLE (EMPNO IS COMPULSORY VALUE)
INSERT INTO EMP_VIEW_ENAME_SAL_COMM (ENAME,SAL,COMM) VALUES ('OGGY',700,70)


CREATE SEQUENCE EMP_SEQ 
START WITH 1001 
INCREMENT BY 1 
MINVALUE 1001 
MAXVALUE 2000 
NO CYCLE
CACHE 100

INSERT INTO EMP(EMPNO,ENAME) VALUES (NEXT VALUE FOR EMP_SEQ , 'OGGY'
SELECT * FROM EMP

CREATE OR ALTER VIEW EMP_RANK_AS_SAL AS 
SELECT SAL,ROW_NUMBER () OVER (ORDER BY SAL DESC) RANK_AS_SAL FROM EMP;

CREATE OR ALTER VIEW EMP_RANK_AS_SAL AS 
SELECT SAL,RANK () OVER (ORDER BY SAL DESC) RANK_AS_SAL FROM EMP;

CREATE OR ALTER VIEW EMP_RANK_AS_SAL AS 
SELECT SAL,DENSE_RANK () OVER (ORDER BY SAL DESC) RANK_AS_SAL FROM EMP;

SELECT EMPNO,ENAME,SAL,DEPTNO, ROW_NUMBER() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) RANK_AS_DEPT FROM EMP;

SELECT * FROM EMP_RANK_AS_SAL

SELECT * FROM EMP;
SELECT * FROM DEPT;

-- ASSIGNMENT 4

--1) Create a view that displays employee details along with their department name and location
CREATE OR ALTER VIEW EMP_DEPT_LOC AS SELECT EMP.ENAME , DEPT.DNAME , DEPT.LOC FROM EMP INNER JOIN DEPT ON DEPT.DEPTNO = EMP.DEPTNO

--2) Create a sequence for generating employee numbers starting at 100 and incrementing by 5 . Use this sequence to insert a new employee.
CREATE SEQUENCE EMPNUMS START WITH 100 INCREMENT BY 5 MINVALUE 100 MAXVALUE 2000 NO CYCLE CACHE 100

--3) Create a view that shows the top 3 highest-paid employees in each department 
CREATE OR ALTER VIEW EMP_TOP_3_SAL AS SELECT ENAME,SAL,DEPTNO, RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) AS "RANK_SAL" FROM EMP ;
SELECT * FROM EMP_TOP_3_SAL WHERE RANK_SAL<=3

--4) Create a view that lists employees whose salary is above the average salary of their department.
CREATE OR ALTER VIEW EMP_GRET_AVG_SAL AS SELECT * FROM EMP E WHERE SAL > (SELECT AVG(SAL) FROM EMP WHERE E.DEPTNO = DEPTNO)

--6) Create a view that lists the total number of employees and the total salary sum for each department.
CREATE OR ALTER VIEW EMP_SAL_DEPT AS SELECT COUNT(*) "NO_OF_PEOPLE" , SUM(SAL) "SAL_SUM" FROM EMP GROUP BY DEPTNO

--7) Create a view that lists employees who were hired in the last 5 years, and rank them based on their hire date.
CREATE OR ALTER VIEW EMP_LAST_5_HIRED AS SELECT *,RANK() OVER(ORDER BY HIREDATE DESC) "RANK_AS_PER_HIRING" FROM EMP WHERE YEAR(HIREDATE) > YEAR(GETDATE())-42

--5) Create a view that lists the median salary for each department using ranking functions. 
--// INCOMPLETE
CREATE OR ALTER VIEW DEPT_AVG_SAL AS SELECT RANK() OVER (ORDER BY (SELECT AVG(SAL) "AVG_SAL_DEPT" FROM EMP GROUP BY DEPTNO) DESC) "RANK_AS_PER_SAL" FROM EMP
SELECT * FROM DEPT_AVG_SAL

--8) Create a view that lists the top 2 earners in each department along with their department name and the difference between their salary and the average salary of the department 
--// INCOMPLETE
SELECT EMP.ENAME , DEPT.DNAME , DEPT.DEPTNO , EMP.SAL-(SELECT AVG(SAL) FROM EMP E WHERE DEPTNO = E.DEPTNO GROUP BY DEPTNO) FROM EMP INNER JOIN

--9) Create a view to identify employees with the longest tenure in their departments, ranked by their hire date. 
-- // INCOMPLETE
CREATE OR ALTER VIEW EMP_LONGEST_TENU AS SELECT 

--10) Create a view that shows the total salary, average salary, and number of employees for each department.
CREATE OR ALTER VIEW EMP_TOP_10_SAL AS SELECT SUM(SAL) "SUM_OF_SAL" ,AVG(SAL) "AVG_OF_SAL" ,COUNT(*) "COUNT_OF_PEOPLE" FROM EMP GROUP BY DEPTNO

--11) Create a view to find employees whose salary is in the top 10% of all salaries.
CREATE OR ALTER VIEW EMP_TOP_10_SAL AS SELECT * FROM EMP WHERE SAL IN (SELECT TOP 10 PERCENT SAL FROM EMP ORDER BY SAL DESC) ORDER BY SAL DESC offset 0 rows
SELECT * FROM EMP_TOP_10_SAL

--12) Create a view that shows the average salary for each job title within each department.
CREATE OR ALTER VIEW AVG_SAL_DEPT_JOB AS SELECT JOB,DEPTNO,AVG(SAL) "AVG_SAL_FOR_EACH_JOB" FROM EMP GROUP BY JOB,DEPTNO




-- DAY 5

--STORED PROCEDURES

CREATE TABLE TEMPP(
FIRST INT,
SECOND CHAR(25)
);

BEGIN
-- TRANSACT SQL BLOCK

INSERT INTO TEMPP VALUES(1,'ADI')


END


BEGIN
	BEGIN
		INSERT INTO TEMPP VALUES(2,'PRANAV')
	END
END

SELECT FIRST,SECOND FROM TEMPP

-- DECLARE @variable_name datatype = value
BEGIN
	DECLARE @X CHAR = 'PARTH'
	BEGIN
		DECLARE @Y INT = 5
		INSERT INTO TEMPP VALUES (@Y,@X)
	END
END

BEGIN
	SELECT FIRST,SECOND FROM TEMPP		-- WILL WORK BUT SHOULD NOT BE DONE (DISPLAY ON SERVER SIDE)
END



BEGIN
	DROP TABLE TEMPP		-- INTEGRITY MUST BE MAINTAINED
END



BEGIN
	DECLARE @SAL INT = 3000
	BEGIN
		IF @SAL > 5000
			INSERT INTO TEMPP VALUES (@SAL,'RICH MAN')
		ELSE
			INSERT INTO TEMPP VALUES (@SAL,'POOR MAN')
	END
END


BEGIN
	DECLARE @SAL INT
	BEGIN
		SELECT @SAL = SAL FROM EMP WHERE ENAME='KING'
		IF @SAL > 5000
			INSERT INTO TEMPP VALUES (@SAL,'RICH MAN')
		ELSE
			INSERT INTO TEMPP VALUES (@SAL,'POOR MAN')
	END
END


BEGIN
	DECLARE @COUNT = 1
	WHILE @COUNT <= 5
		BEGIN
			INSERT INTO TEMPP VALUES(@COUNT,'INSIDE LOOP')
			SET @COUNT = @COUNT + 1
		END
END


-- CURSORS:
-- ITS A BLOCK OF MEMEORY THAT EXECUTES TO STORE MULTIPLE ROWS INTERNALLY LIKE 2D ARRAY

DELETE FROM TEMPP

DECLARE CUR_EMP CURSOR FOR SELECT EMPNO , ENAME FROM EMP

DECLARE @EMPNO INT
DECLARE @ENAME VARCHAR(25)

OPEN CUR_EMP		-- OPENING CURSOR CURSOR EXCEUTES

BEGIN
	FETCH NEXT FROM CUR_EMP INTO @EMPNO,@ENAME
	WHILE @@FETCH_STATUS = 0
		BEGIN
			INSERT INTO TEMPP VALUES (@EMPNO,@ENAME)
			FETCH NEXT FROM CUR_EMP INTO @EMPNO,@ENAME
		END
END

CLOSE CUR_EMP		-- FREES THE RESOURCES
DEALLOCATE CUR_EMP		-- RELEASES THE MEMORY ASSIGNED



BEGIN TRY
	DECLARE @SMITHSAL INT 
	BEGIN
		SELECT @SMITHSAL = SAL FROM EMP WHERE ENAME = 'SMITH'
		IF @SMITHSAL > 2000
			INSERT INTO TEMPP VALUES(@SMITHSAL,'ABOVE 2000')
		ELSE
			THROW 50001, 'ERROR: SALARY MUST BE ABOVE 2000' , 1
	END
END TRY

BEGIN CATCH
	SELECT ERROR_NUMBER() AS "ERROR NUMBER"
	SELECT ERROR_MESSAGE() AS "MESSAGE"
END CATCH



--CREATE OR ALTER PROCEDURE ADDEMPLOYEE 
--AS
--BEGIN
--	INSERT INTO TEMPP VALUES (2,'TIRTH')
--END

-- EXEC ADDEMPLOYEE

--CREATE OR ALTER PROCEDURE ADDEMPLOYEE (@EMPNO INT , @ENAME VARCHAR(25))
--AS
--BEGIN
--	INSERT INTO TEMPP VALUES (@EMPNO,@ENAME)
--END

--EXEC ADDEMPLOYEE 2 , 'TIRTH'

CREATE OR ALTER PROCEDURE ADDEMPLOYEE (
	@EMPNO INT ,
	@ENAME VARCHAR(25),
	@JOB VARCHAR(9),
	@MGR INT,
	@HIREDATE DATE,
	@SAL FLOAT,
	@COMM FLOAT,
	@DEPTNO INT
)
AS
BEGIN
	BEGIN TRY
		IF NOT EXISTS (SELECT 1 FROM EMP WHERE EMPNO = @EMPNO)
			INSERT INTO EMP VALUES (@EMPNO,@ENAME,@JOB,@MGR,@HIREDATE,@SAL,@COMM,@DEPTNO)
		ELSE
			--THROW 50004, 'ERROR: USER ALREADY EXIST' , 1
			RAISEERROR('ERROR : USER ALREADY EXIST',16,1)
	END TRY

	BEGIN CATCH
		SELECT ERROR_NUMBER() AS "ERROR NUMBER"
		SELECT ERROR_MESSAGE() AS "MESSAGE"
	END CATCH
END

EXEC ADDEMPLOYEE 1117,'TIRTH' ,'SALESMAN',7369,GETDATE(),3000,300,20
SELECT * FROM EMP

SELECT SYS.PROCEDURES

SELECT * FROM TEMPP

DELETE FROM TEMPP


use payroll;
select * from emp;

-- ASSIGNMENT 5

--1. Create a CTE that lists all employees with their department names.
WITH EMPLOYEEDEPTNAMES AS (
	SELECT DEPTNO,DNAME FROM DEPT 
)SELECT EMP.EMPNO,EMP.ENAME,EMP.DEPTNO,EMPLOYEEDEPTNAMES.DNAME FROM EMP 
INNER JOIN EMPLOYEEDEPTNAMES 
ON EMP.DEPTNO = EMPLOYEEDEPTNAMES.DEPTNO 

--2. Create a CTE to find the total salary for each department.
WITH TOTALSALDEPT AS (
	SELECT DEPTNO,DNAME FROM DEPT
)SELECT TOTALSALDEPT.DEPTNO,SUM(SAL) FROM EMP 
INNER JOIN TOTALSALDEPT 
ON EMP.DEPTNO = TOTALSALDEPT.DEPTNO GROUP BY TOTALSALDEPT.DEPTNO

--3. Create a CTE to rank employees by their salary within each department. 
WITH RANKSALBYDEPT AS(
	SELECT ENAME,EMPNO,DEPTNO,DENSE_RANK () OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) "RANK_BY_DEPT" FROM EMP 
) SELECT DEPT.DNAME,RANKSALBYDEPT.ENAME,RANKSALBYDEPT.EMPNO ,RANKSALBYDEPT."RANK_BY_DEPT" FROM DEPT 
INNER JOIN RANKSALBYDEPT ON DEPT.DEPTNO = RANKSALBYDEPT.DEPTNO


--4. Create a CTE to list employees who were hired in the last year.
WITH LASTYEARHIREDEPT AS (
	SELECT EMPNO,ENAME FROM EMP WHERE DATEDIFF(YYYY,HIREDATE,GETDATE()) = 43
) SELECT EMPNO,ENAME FROM LASTYEARHIREDEPT 

--5. Create a CTE to list departments that have more than 5 employees.
WITH DEPTMORETHAN5EMP AS (
	SELECT DEPTNO FROM EMP GROUP BY DEPTNO HAVING COUNT(*)>5
) SELECT DEPT.DNAME,DEPT.DEPTNO FROM DEPT INNER JOIN DEPTMORETHAN5EMP ON DEPT.DEPTNO = DEPTMORETHAN5EMP.DEPTNO 

--6) Create a CTE to calculate the total salary (including commission) for each employee.
WITH TOTALSAL AS (
	SELECT EMPNO,SAL+ISNULL(COMM,0) "TOTALSALARY" FROM EMP 
) SELECT EMP.ENAME ,  TOTALSAL.TOTALSALARY FROM EMP , TOTALSAL WHERE EMP.EMPNO = TOTALSAL.EMPNO

--7) Create a CTE to find the highest salary in each department.
WITH HIGHESTSAL AS (
	SELECT DEPTNO,MAX(SAL) "MAXSALARY" FROM EMP GROUP BY DEPTNO
) SELECT DEPT.DNAME , HIGHESTSAL.MAXSALARY FROM DEPT , HIGHESTSAL WHERE DEPT.DEPTNO = HIGHESTSAL.DEPTNO

